{"version":3,"sources":["main.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["'use strict';\n\nconsole.log('funciona');\n\nconst button = document.querySelector('.button');\nconst input = document. querySelector ('.input');\nconst lista = document.querySelector ('.lista');\n\n\n// let arrayResultados = [];\n\n\nfunction handlerFunction(){\n  let userinput = input.value;\n  fetch(`http://api.tvmaze.com/search/shows?q=${userinput}`)\n    .then(function(response){\n      return response.json();\n    })\n    .then(function(data){\n      console.log(data);\n      console.log('Esta de arriba es la respuesta de data');\n\n      for (let i = 0; i < data.length; i++){\n        // console.log(data[i].show.name);\n        // console.log(data[i].show.image.medium);\n        \n        if (data[i].show.image === null){\n          lista.innerHTML += (`<li> ${data[i].show.name} </li> <img src='https://via.placeholder.com/210x295/ffffff/666666/?text=TV>'`);\n        } else {\n          lista.innerHTML += (`<li> ${data[i].show.name} </li> <img src=${data[i].show.image.medium}>`);\n        }\n      }\n    });\n}\n\nbutton.addEventListener('click', handlerFunction);\n\n\n// localStorage.setItem('film', JSON.stringify(arrayResultados));\n//\n//Ahora mismo se me imprime solo una vez. Quiero que se me imprima tantas veces como elementos hay en el array. Quiero que el bucle recorra todo el array y en cada elemento me de el name y el medium. y que vaya imprimiendo lo que tiene mas lo nuevo que le doy en el siguiente elemento.\n\n\n// En lista debe ir el arrray de resultados, que debe recorrerlo para darme de cada uno de los objetos del array su image y su name.\n\n\n// Por cada show contenido en el resultado de búsqueda debemos pintar una tarjeta\n// donde mostramos una imagen de la serie y el título.\n// NOTA: Para pintar la información en la página puedes elegir hacerlo de forma básica con\n// innerHTML o manipulando de forma avanzada el DOM\n\n\n// Algunas de las series que obtenemos en los resultados no tienen imagen. En ese caso debemos\n// mostrar una imagen de relleno. Podemos crear una imagen de relleno con el servicio de\n// placeholder.com donde en la propia URL indicamos el tamaño, colores, texto:\n// https://via.placeholder.com/210x295/ffffff/666666/?text=TV\n\n\n// 3. Favoritos\n// Una vez aparecen los resultados de búsqueda, podremos indicar cuáles son nuestras series\n// favoritas. Para ello, al hacer clic sobre un resultado el color de fondo y el de fuente se\n// intercambian.\n\n\n// Además, debes crear un listado (array) con las series favoritas que almacenamos en una variable.\n// Este listado lo mostraremos en la parte izquierda de la pantalla, debajo del formulario de búqueda.\n// Para terminar, si volvemos a realizar una nueva búsqueda, los favoritos se irán acumulando en\n// nuestra lista.\n\n\n// 4. Almacenamiento local\n// Vamos a almacenar el listado de favoritos en el localStorage. De esta forma, al recargar la página\n// el listado de favoritos se mantiene.\n\n\n// 5. BONUS: Afinar la maquetación\n// Una vez terminada la parte de interacción, podemos centrarnos en la parte de maquetación donde\n// tenéis libertad para decidir los estilo. En cualquier caso os dejamos una propuesta gráfica.\n\n\n// 6. BONUS: Borrar favoritos\n// Como bonus, os proponemos la opción de borrar favoritos. De esta forma, al hacer clic sobre el\n// icono de la 'x' al lado de los favoritos, podremos borrarlos (de nuestra lista y del localStorage).\n\n\n// Para terminar de rematar nuestra app de series, nos gustaría poder añadir/quitar favorito al hacer\n// clic sobre una serie. Y que, si realizamos una nueva búsqueda y sale una serie que ya es favorita,\n// aparezca ya resaltada en los resultados de búsqueda (con colores de fondo y texto\n// intercambiados).\n\n\n// Y ya sería fantástico si al final de la lista de favoritos tenemos un botón para borrarlos todos.\n\n\n\n// Criterios de evaluación\n// Vamos a listar los criterios de evaluación de este ejercicio. Si no superas al menos el 80% de estos criterios o no has superado algún criterio clave (marcados con *) te pediremos que realices una re‒evaluación \n\n// JavaScript básico\n// Crear código JavaScript con sintaxis correcta, bien estructurado e indentado*\n// Usar constantes/variables para almacenar información y re‒asignar valores*\n// Usar condicionales para ejecutar acciones distintas en función de una condición\n// Saber trabajar con listados de datos (arrays)*\n// Usar funciones para estructurar el código\n// Saber modificar la información del DOM para añadir contenido dinámico*\n// Saber escuchar eventos del DOM y actuar en consecuencia*\n// AJAX y APIs\n// Crear peticiones con fetch y promesas*\n// Saber trabajar correctamente con la respuesta del servidor*\n// Gestionar información en formato JSON\n// Usar el localStorage para guardar información en el navegador\n// Issues\n// Haber resuelto las issues de la evaluación intermedia\n// Otros criterios a tener en cuenta\n// Usar inglés para nombres de variables, funciones, clases, mensajes de commit, nombres de ficheros\n// El repositorio de GitHub debe tener README y un enlace a la web en GitHub Pages accesible desde la página principal\n\n// ¡Al turrón!\n\n"]}